#ifndef ERDEFFECTIVECHANGEMERGER_H
#define ERDEFFECTIVECHANGEMERGER_H

#include "erdeffectivechange.h"
#include <QStringList>

class ErdChange;
class Db;

/**
 * @brief The ErdEffectiveChangeMerger class is responsible for merging multiple ErdChange instances
 *        into a minimized list of ErdEffectiveChange instances.
 */
class ErdEffectiveChangeMerger
{
    public:
        /**
         * @brief Constructor
         * @param schemaBase Database schema as list of DDL statements in state applicable for changes to be merged.
         * @param dbName Name of the database (used for in-memory database creation, so that all extensions/functions, etc are loaded by name).
         */
        ErdEffectiveChangeMerger(const QStringList& schemaBase, const QString& dbName);

        /**
         * @brief Merges a list of ErdChange instances into a minimized list of ErdEffectiveChange instances.
         * @param changes List of ErdChange instances to be merged.
         * @return List of merged ErdEffectiveChange instances.
         */
        QList<ErdEffectiveChange> merge(const QList<ErdChange*>& changes);

        /**
         * @brief Generates DDL statements for the provided effective change.
         * @param change Effective change to generate DDL for.
         * @return List of DDL statements representing the effective change.
         *
         * This method uses an internal cache to avoid regenerating DDL for the same change multiple times,
         * unlike the overload that accepts a Db* parameter.
         *
         * Use this variant of the method only on an ErdEffectiveChange that was generated by this merger instance.
         * Otherwise it will return empty list.
         *
         * @see generateDdl(const ErdEffectiveChange& change, Db* db)
         */
        QStringList getDdlForChange(const ErdEffectiveChange& change) const;

        /**
         * @brief Creates an in-memory database and applies the provided schema DDL statements to it.
         * @param schemaDdls Database schema as list of DDL statements in state applicable for changes to be merged.
         * @param name Name of the database (used for in-memory database creation, so that all extensions/functions, etc are loaded by name).
         * @return Pointer to created in-memory database, or nullptr on failure.
         */
        static Db* createMemDbWithSchema(const QStringList& schemaDdls, const QString& name);

        /**
         * @brief Reads the full database schema as a list of DDL statements.
         * @param db Database to read the schema from.
         * @return List of DDL statements representing the database schema.
         *
         * This method retrieves the schema for tables, views, triggers, and indexes, in that particular order,
         * so they can be reused in returned order to recreate the database schema accurately.
         */
        static QStringList readDbSchema(Db* db);

    private:
        QList<ErdChange*> flatten(const QList<ErdChange*>& changes);
        ErdEffectiveChange merge(const QList<ErdEffectiveChange>& theList, int& idx, Db* referenceDb, Db* workingDb);
        ErdEffectiveChange mergeToCreateChange(const QList<ErdEffectiveChange>& theList, int& idx, Db* referenceDb, Db* workingDb);
        ErdEffectiveChange mergeToDropChange(const QList<ErdEffectiveChange>& theList, int& idx, Db* referenceDb, Db* workingDb);
        ErdEffectiveChange mergeToModifyChange(const QList<ErdEffectiveChange>& theList, int& idx, Db* referenceDb, Db* workingDb);
        ErdEffectiveChange mergeMultipleModifyToOne(const QList<ErdEffectiveChange>& theList, int& idx, Db* referenceDb, Db* workingDb);
        ErdEffectiveChange mergeModifyToDropAhead(const QList<ErdEffectiveChange>& theList, int& idx, Db* referenceDb, Db* workingDb);
        ErdEffectiveChange mergeMultipleModifyToCreateChange(const QList<ErdEffectiveChange>& theList, int& idx, Db* referenceDb, Db* workingDb);
        ErdEffectiveChange mergeDropToCreateChange(const QList<ErdEffectiveChange>& theList, int& idx, Db* referenceDb, Db* workingDb);

        /**
         * @brief Generates a schema snapshot of the provided database as a single string.
         * @param db Database to generate the schema snapshot from.
         * @return String representing the database schema.
         */
        QString schemaSnapshot(Db* db);

        /**
         * @brief Tests whether applying the merged change to the working database
         *        results in the same schema as applying the reference changes to the reference database.
         * @param mergedChange Planned merged change to be tested
         * @param referenceChanges List of reference changes to be applied to the reference database.
         * @param referenceDb In-memory db with schema before applying reference changes.
         * @param workingDb In-memory db with schema before applying merged change.
         *        It must have same schema as referenceDb before applying changes, but it has to be a separate in-memory db.
         * @return True if the merged change produces the same schema as the reference changes, false otherwise.
         *
         * Any tested changes are rolled back after the test, so both databases remain unchanged.
         */
        bool testAgainstOriginal(ErdEffectiveChange mergedChange, const QList<ErdEffectiveChange>& referenceChanges,
                                 Db* referenceDb, Db* workingDb);

        /**
         * @brief Outputs debug information about differences between two schema snapshots.
         * @param refSchema Schema from reference database.
         * @param workingSchema Schema from working database.
         *
         * It's used in testAgainstOriginal() method to log differences when schemas do not match.
         */
        void debugSnapshotDiff(const QString& refSchema, const QString& workingSchema);

        /**
         * @brief Executes a single effective change on both reference and working databases.
         * @param change Effective change to be executed.
         * @param referenceDb In-memory db with schema before applying reference changes.
         * @param workingDb In-memory db with schema before applying merged change.
         *
         * This method applies the same change to both databases to keep them in sync.
         * It is executed after the effective change is accepted as valid in the merging process.
         */
        void executeOneChangeOnBothDbs(ErdEffectiveChange change, Db* referenceDb, Db* workingDb);

        /**
         * @brief Generates DDL statements for the provided effective change using the specified database.
         * @param change Effective change to generate DDL for.
         * @param db Database to use for generating the DDL statements.
         * @return List of DDL statements representing the effective change.
         */
        QStringList generateDdl(const ErdEffectiveChange& change, Db* db);

        /**
         * @brief Gets DDL statements for the provided effective change using the specified database,
         *        with caching to avoid redundant generation.
         * @param change Effective change to get DDL for.
         * @param db Database to use for generating the DDL statements.
         * @return List of DDL statements representing the effective change.
         */
        QStringList getDdlForChange(const ErdEffectiveChange& change, Db* db);

        QStringList schemaBase;
        QString dbName;
        QHash<QString, QStringList> ddlCacheByChangeId;
};

#endif // ERDEFFECTIVECHANGEMERGER_H
